<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ƒ∞ngilizce A1 C√ºmle Kurma Programƒ±</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    @keyframes highlight { 0% { transform: scale(1); } 20% { transform: scale(1.15) rotate(2deg); filter: brightness(1.8); } 100% { transform: scale(1); } }
    @keyframes bounce-error { 0%, 100% { transform: translateX(0); } 20%, 60% { transform: translateX(-5px); } 40%, 80% { transform: translateX(5px); } }
    @keyframes fall {
      0% { transform: translateY(-10vh) rotate(0deg) scale(1); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg) scale(0.5); opacity: 0; }
    }

    .animate-highlight { animation: highlight 1.2s ease-in-out; z-index: 50; }
    .animate-bounce-error { animation: bounce-error 0.4s ease-in-out; }
    
    .confetti-particle {
      position: absolute;
      top: -20px;
      animation-name: fall;
      animation-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      animation-fill-mode: forwards;
    }

    .hide-scrollbar::-webkit-scrollbar { display: none; } 
    .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; } 
    .custom-scrollbar::-webkit-scrollbar { width: 4px; height: 4px; } 
    .custom-scrollbar::-webkit-scrollbar-track { background: transparent; } 
    .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.1); border-radius: 10px; } 
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.2); }
  </style>
</head>
<body class="bg-slate-100 font-sans text-slate-800">
  <div id="root" class="h-screen w-full flex flex-col overflow-hidden relative"></div>

  <script>
    // --- VERƒ∞ TABANLARI ---
    const SEMANTIC_GROUPS = {
      food: ["pizza üçï", "an apple üçé", "bread üçû", "cake üç∞", "a sandwich ü•™", "dinner ü•ò", "soup üç≤", "eggs üç≥", "meat ü•©", "banana üçå", "pasta üçù", "a burger üçî", "a cookie üç™", "salad ü•ó", "chicken üçó", "cheese üßÄ", "fish üêü", "rice üçö"],
      liquid: ["water üíß", "milk ü•õ", "tea ‚òï", "coffee ‚òï", "juice üçπ", "coke ü•§", "lemonade üçã", "hot chocolate ‚òï", "orange juice üçä", "milkshake ü•§"],
      media: ["TV üì∫", "a movie üé¨", "a story üìñ", "a book üìö", "the board üìã", "photos üñºÔ∏è", "a video üìπ", "the lesson üéì", "music üé∂", "a song üéµ", "news üì∞", "cartoons üì∫", "a poem üìú", "homework üìñ"],
      activity: ["video games üïπÔ∏è", "the ball ‚öΩ", "a gift üéÅ", "a kite ü™Å", "a puzzle üß©", "chess ‚ôüÔ∏è", "football ‚öΩ", "tennis üéæ", "the piano üéπ", "the guitar üé∏", "a toy üß∏", "a bike üö≤", "cards üÉè", "basketball üèÄ", "drawing üé®"],
      place: ["to school üè´", "to the park üå≥", "home üè†", "to bed üõèÔ∏è", "the house üè†", "the room üßπ", "the garden üè°", "to the beach üèñÔ∏è", "the kitchen üç≥", "the city üåÜ", "in the forest üå≤", "at the zoo üêæ", "in the jungle üå¥"],
      sleep_place: ["in bed üõå", "on the sofa üõãÔ∏è", "in the room üßπ", "at home üè†", "in the garden üè°", "under the tree üå≥"],
      tool: ["a pen üñäÔ∏è", "a pencil ‚úèÔ∏è", "a laptop üíª", "scissors ‚úÇÔ∏è", "a map üó∫Ô∏è", "the table ü™ë", "the desk ü™ë", "the car üöó", "the window ü™ü", "the plate üçΩÔ∏è", "a phone üì±", "a bag üéí", "a computer üíª", "a cup ü•õ"]
    };

    const VERB_COMPATIBILITY = {
      "eat": ["food"], "drink": ["liquid"], "watch": ["media"], "read": ["media"], "play": ["activity"], "cook": ["food"],
      "clean": ["place", "tool", "sleep_place"], "wash": ["tool", "food"], "like": ["food", "liquid", "media", "activity", "tool", "place", "sleep_place"],
      "want": ["food", "liquid", "media", "activity", "tool", "place", "sleep_place"], "have": ["food", "liquid", "activity", "tool"],
      "buy": ["food", "liquid", "tool", "activity"], "see": ["food", "media", "activity", "place", "tool", "sleep_place"],
      "go": ["place"], "write": ["media", "tool"], "use": ["tool"], "open": ["media", "tool"], "need": ["food", "liquid", "tool", "activity"],
      "sleep": ["sleep_place", "place"], "run": ["place"], "jump": ["place"] 
    };

    const GRAMMAR_GROUPS = {
      firstPerson: ["I üôã‚Äç‚ôÇÔ∏è"],
      thirdSingular: ["he üë®", "she üë©", "it üê∂", "my mother üë©", "my father üë®", "the cat üê±", "the teacher üë©‚Äçüè´", "the dog üê∂", "the bird üê¶", "the lion ü¶Å", "the monkey üêµ", "the elephant üêò"],
      pluralOrSecond: ["you ü´µ", "we üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "they üë•", "students üßë‚Äçüéì", "the boys üë¶", "the girls üëß", "your friend üë¶"]
    };

    const CATEGORIES = {
      home: {
        id: 'home', label: 'Ev', icon: 'home', color: '#f97316', requiredStars: 0,
        modals: ["can", "will", "must", "should"], auxiliaries: ["Do", "Does", "Can", "Is", "Are", "Am"], statusAux: ["am", "is", "are"],
        subjects: GRAMMAR_GROUPS.firstPerson.concat(GRAMMAR_GROUPS.thirdSingular).concat(["you ü´µ", "we üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "they üë•"]),
        verbs: ["eat üçΩÔ∏è", "drink ü•§", "like üòã", "want ü•£", "cook üç≥", "sleep üò¥", "clean üßπ", "wash üßº"],
        objects: [...SEMANTIC_GROUPS.food, ...SEMANTIC_GROUPS.liquid, ...SEMANTIC_GROUPS.sleep_place, ...SEMANTIC_GROUPS.tool],
        adjectives: ["hungry üòã", "thirsty ü•§", "full ü§∞", "happy üòä", "tired üò´", "ready üèÅ", "late ‚è∞", "sad üò¢", "brave ü¶Å", "strong üí™", "kind ‚ù§Ô∏è", "angry üò°", "sleepy ü•±", "excited ü§©", "silly ü§™", "cool üòé", "quiet ü§´", "loud üì¢", "lucky üçÄ", "scared üò®"]
      },
      games: {
        id: 'games', label: 'Oyun', icon: 'gamepad-2', color: '#a855f7', requiredStars: 0,
        modals: ["can", "will", "must", "could"], auxiliaries: ["Do", "Can", "Is", "Are"], statusAux: ["am", "is", "are"],
        subjects: ["you ü´µ", "we üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "they üë•", "your friend üë¶", "it ü§ñ", "the boys üë¶", "the girls üëß"],
        verbs: ["play üéÆ", "win üèÜ", "find üîé", "want üèóÔ∏è", "have üß∏", "start üèÅ", "sleep üò¥"],
        objects: [...SEMANTIC_GROUPS.activity, ...SEMANTIC_GROUPS.sleep_place],
        adjectives: ["fast ‚ö°", "slow üê¢", "exciting ü§©", "easy ‚úÖ", "hard ‚ùå", "fun üéà", "boring üò¥", "lucky üçÄ", "surprised üò≤"]
      },
      school: {
        id: 'school', label: 'Okul', icon: 'school', color: '#3b82f6', requiredStars: 0,
        auxiliaries: ["Do", "Does", "Can", "Is"], statusAux: ["am", "is", "are"],
        subjects: ["the teacher üë©‚Äçüè´", "students üßë‚Äçüéì", "I üôã‚Äç‚ôÇÔ∏è", "my friend üë¶", "she üë©", "he üë®"],
        verbs: ["read üìñ", "write üìù", "use üíª", "open üìñ", "need ‚úèÔ∏è", "learn üß†", "sleep üò¥"],
        objects: [...SEMANTIC_GROUPS.tool, ...SEMANTIC_GROUPS.media, ...SEMANTIC_GROUPS.sleep_place],
        adjectives: ["smart üß†", "busy ‚úçÔ∏è", "difficult üß©", "ready üèÅ", "late ‚è∞", "correct ‚úÖ", "silent ü§´", "perfect üíØ", "careful üßê", "polite ü§ù"]
      },
      animals: {
        id: 'animals', label: 'Hayvanlar', icon: 'cat', color: '#10b981', requiredStars: 10,
        modals: ["can", "will", "must"], auxiliaries: ["Do", "Does", "Can", "Is", "Are"], statusAux: ["is", "are"],
        subjects: ["the cat üê±", "the dog üê∂", "the bird üê¶", "the lion ü¶Å", "the monkey üêµ", "the elephant üêò", "they üë•", "it üê∂"],
        verbs: ["run üèÉ", "jump ü¶ò", "eat üçΩÔ∏è", "drink ü•§", "sleep üò¥", "play üéÆ"],
        objects: [...SEMANTIC_GROUPS.food, ...SEMANTIC_GROUPS.liquid, "in the forest üå≤", "at the zoo üêæ", "in the jungle üå¥", "to the park üå≥"],
        adjectives: ["fast ‚ö°", "slow üê¢", "cute ü•∫", "scary üò®", "hungry üòã", "thirsty ü•§", "sleepy ü•±", "wild üêæ", "funny üòÇ", "big üêò", "small üê≠"]
      }
    };

    const MODE_LABELS = {
      simple: 'Her zaman', negative: 'Olumsuz üö´', continuous: '≈ûimdiki',
      status: 'Durum', modal: 'Yetenek', question: 'Soru'
    };

    // --- YEREL √áEVƒ∞Rƒ∞ S√ñZL√úƒû√ú (API OLMADAN √áEVƒ∞Rƒ∞ ƒ∞√áƒ∞N) ---
    const TR_DICT = {
      "i": "ben", "he": "o", "she": "o", "it": "o", "you": "sen", "we": "biz", "they": "onlar",
      "the cat": "kedi", "the dog": "k√∂pek", "the bird": "ku≈ü", "the lion": "aslan", "the monkey": "maymun", "the elephant": "fil",
      "the teacher": "√∂ƒüretmen", "students": "√∂ƒürenciler", "my mother": "annem", "my father": "babam", "your friend": "arkada≈üƒ±n",
      "the boys": "√ßocuklar", "the girls": "kƒ±zlar",
      "pizza": "pizza", "an apple": "elma", "bread": "ekmek", "cake": "pasta", "a sandwich": "sandvi√ß", "dinner": "ak≈üam yemeƒüi",
      "soup": "√ßorba", "eggs": "yumurta", "meat": "et", "banana": "muz", "pasta": "makarna", "a burger": "hamburger",
      "a cookie": "kurabiye", "salad": "salata", "chicken": "tavuk", "cheese": "peynir", "fish": "balƒ±k", "rice": "pilav",
      "water": "su", "milk": "s√ºt", "tea": "√ßay", "coffee": "kahve", "juice": "meyve suyu", "coke": "kola", "lemonade": "limonata",
      "hot chocolate": "sƒ±cak √ßikolata", "orange juice": "portakal suyu", "milkshake": "milkshake",
      "tv": "televizyon", "a movie": "film", "a story": "hikaye", "a book": "kitap", "the board": "tahta", "photos": "fotoƒüraflar",
      "a video": "video", "the lesson": "ders", "music": "m√ºzik", "a song": "≈üarkƒ±", "news": "haberler", "cartoons": "√ßizgi film",
      "a poem": "≈üiir", "homework": "√∂dev", "video games": "video oyunlarƒ±", "the ball": "top", "a gift": "hediye",
      "a kite": "u√ßurtma", "a puzzle": "yapboz", "chess": "satran√ß", "football": "futbol", "tennis": "tenis",
      "the piano": "piyano", "the guitar": "gitar", "a toy": "oyuncak", "a bike": "bisiklet", "cards": "kartlar",
      "basketball": "basketbol", "drawing": "resim",
      "to school": "okula", "to the park": "parka", "home": "eve", "to bed": "yataƒüa", "the house": "evi",
      "the room": "odayƒ±", "the garden": "bah√ßeyi", "to the beach": "plaja", "the kitchen": "mutfaƒüƒ±", "the city": "≈üehri",
      "in the forest": "ormanda", "at the zoo": "hayvanat bah√ßesinde", "in the jungle": "ormanda",
      "in bed": "yatakta", "on the sofa": "koltukta", "in the room": "odada", "at home": "evde", "in the garden": "bah√ßede", "under the tree": "aƒüacƒ±n altƒ±nda",
      "a pen": "kalem", "a pencil": "kur≈üun kalem", "a laptop": "bilgisayar", "scissors": "makas", "a map": "harita",
      "the table": "masa", "the desk": "sƒ±ra", "the car": "araba", "the window": "pencere", "the plate": "tabak",
      "a phone": "telefon", "a bag": "√ßanta", "a computer": "bilgisayar", "a cup": "bardak",
      "hungry": "a√ß", "thirsty": "susamƒ±≈ü", "full": "tok", "happy": "mutlu", "tired": "yorgun", "ready": "hazƒ±r",
      "late": "ge√ß kalmƒ±≈ü", "sad": "√ºzg√ºn", "brave": "cesur", "strong": "g√º√ßl√º", "kind": "kibar", "angry": "kƒ±zgƒ±n",
      "sleepy": "uykulu", "excited": "heyecanlƒ±", "silly": "komik", "cool": "havalƒ±", "quiet": "sessiz", "loud": "g√ºr√ºlt√ºl√º",
      "lucky": "≈üanslƒ±", "scared": "korkmu≈ü", "fast": "hƒ±zlƒ±", "slow": "yava≈ü", "exciting": "heyecan verici", "easy": "kolay",
      "hard": "zor", "fun": "eƒülenceli", "boring": "sƒ±kƒ±cƒ±", "surprised": "≈üa≈üƒ±rmƒ±≈ü", "smart": "zeki", "busy": "me≈ügul",
      "difficult": "zor", "correct": "doƒüru", "silent": "sessiz", "perfect": "m√ºkemmel", "careful": "dikkatli", "polite": "kibar",
      "cute": "sevimli", "scary": "korkutucu", "wild": "vah≈üi", "funny": "komik", "big": "b√ºy√ºk", "small": "k√º√ß√ºk",
      "eat": "yemek", "drink": "i√ßmek", "watch": "izlemek", "read": "okumak", "play": "oynamak", "cook": "pi≈üirmek", "clean": "temizlemek",
      "wash": "yƒ±kamak", "like": "sevmek", "want": "istemek", "have": "sahip olmak", "buy": "almak", "see": "g√∂rmek", "go": "gitmek",
      "write": "yazmak", "use": "kullanmak", "open": "a√ßmak", "need": "ihtiya√ß duymak", "sleep": "uyumak", "run": "ko≈ümak", "jump": "zƒ±plamak",
      "win": "kazanmak", "find": "bulmak", "start": "ba≈ülamak", "learn": "√∂ƒürenmek"
    };

    // --- UYGULAMA DURUMU (STATE) ---
    const state = {
      showLogin: true,
      userName: '',
      nameInput: '',
      activeCategory: 'home',
      mode: 'simple',
      sentence: { aux: null, modal: null, subject: null, verb: null, object: null, adjective: null, ingVerb: null },
      isComplete: false,
      translation: '',
      isSpeaking: false,
      score: 0,
      selectedPiece: null,
      leftDrawerOpen: false,
      rightDrawerOpen: false,
      isRecording: false,
      isEvaluating: false,
      pronunciationFeedback: '',
      micAttempts: 0,
      micSuccess: false
    };

    let localSpeechRecognition = null;
    let currentDragSlot = null;

    // --- YARDIMCI FONKSƒ∞YONLAR ---
    const escapeHTML = str => String(str).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m]));
    
    // G√ú√áLENDƒ∞Rƒ∞LMƒ∞≈û TEMƒ∞ZLEYƒ∞Cƒ∞ (U+FE0F ve t√ºm emojileri yok eder, sadece harf kalƒ±r)
    const clean = word => {
        if (!word || typeof word !== 'string') return '';
        return word.replace(/[\u{1F000}-\u{1FAFF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{FE0F}\u{200D}]/gu, '')
                   .replace(/\s+/g, ' ')
                   .trim();
    };

    const getFullText = () => {
      const s = state.sentence;
      const parts = [];
      if (state.mode === 'question') parts.push(clean(s.aux), clean(s.subject), clean(s.verb || s.ingVerb), clean(s.object));
      else if (state.mode === 'negative') parts.push(clean(s.subject), clean(s.aux), clean(s.verb), clean(s.object));
      else {
        parts.push(clean(s.subject));
        if (s.aux) parts.push(clean(s.aux));
        if (s.modal) parts.push(clean(s.modal));
        if (s.verb || s.ingVerb) parts.push(clean(s.verb || s.ingVerb));
        if (s.object) parts.push(clean(s.object));
        if (s.adjective) parts.push(clean(s.adjective));
      }
      return parts.filter(Boolean).join(' ') + (state.mode === 'question' ? '?' : '.');
    };

    const resetGame = () => {
      state.sentence = { aux: null, modal: null, subject: null, verb: null, object: null, adjective: null, ingVerb: null };
      state.isComplete = false;
      state.translation = '';
      state.isSpeaking = false;
      state.selectedPiece = null;
      state.pronunciationFeedback = '';
      state.isEvaluating = false;
      state.micAttempts = 0;
      state.micSuccess = false;
      
      if (localSpeechRecognition && state.isRecording) {
        localSpeechRecognition.stop();
      }
      state.isRecording = false;
    };

    const getMagicRule = () => {
      if (state.isComplete) return state.score % 10 === 0 && state.score > 0 ? "ƒ∞NANILMAZ! YENƒ∞ SEVƒ∞YEYE GE√áTƒ∞N! üöÄüê±" : "Harika! C√ºmlen artƒ±k hazƒ±r! üéâ";
      switch(state.mode) {
        case 'simple': return "Hediye Zamanƒ±: He/She/It fiile 's' takƒ±sƒ± verir! üéÅ";
        case 'negative': return "Hayƒ±r Zamanƒ±: 'Don't' ve 'Doesn't' ile 'yapmam' de! üôÖ‚Äç‚ôÄÔ∏è";
        case 'status': return "K√∂pr√º Kur: am, is, are ile birinin durumunu s√∂yle! üåâ";
        case 'continuous': return "Sihirli An: Fiile '-ing' ekle, ≈üu anƒ± anlat! üïí";
        case 'modal': return "S√ºper G√º√ß: 'Can' ile neler yapabileceƒüini g√∂ster! üí™";
        case 'question': return "Kaptanlar √ñne: Do/Is/Can c√ºmlenin ba≈üƒ±na ko≈üar! üë®‚Äç‚úàÔ∏è";
        default: return "S√ºr√ºkle veya kelimeye tƒ±klayƒ±p bo≈üluƒüa dokun! üëÜ";
      }
    };

    const getPureBaseVerb = (verbRaw) => {
      let cleaned = clean(verbRaw).toLowerCase();
      if (cleaned === 'has') return 'have';
      if (cleaned === 'does') return 'do';
      if (cleaned === 'goes') return 'go';
      if (cleaned === 'washes') return 'wash';
      if (cleaned === 'watches') return 'watch';
      
      let baseV = cleaned.replace(/ing$/, '').replace(/s$/, '');
      if (baseV === 'us' || cleaned === 'using') return 'use';
      if (baseV === 'writ' || cleaned === 'writing') return 'write';
      if (baseV === 'lik' || cleaned === 'liking') return 'like';
      if (baseV === 'mak' || cleaned === 'making') return 'make';
      if (baseV === 'runn' || cleaned === 'running') return 'run';
      if (baseV === 'winn' || cleaned === 'winning') return 'win';
      if (baseV === 'drinki') return 'drink'; 
      return baseV;
    };

    const checkSemanticOnly = (verbRaw, objRaw) => {
      if (!verbRaw || !objRaw) return true;
      const baseVerb = getPureBaseVerb(verbRaw);
      const obj = clean(objRaw).toLowerCase();
      const groups = VERB_COMPATIBILITY[baseVerb];
      if (groups) return groups.some(group => (SEMANTIC_GROUPS[group] || []).some(item => clean(item).toLowerCase() === obj));
      return true;
    };

    const validateHarmony = (type, value, current) => {
      const subj = type === 'subject' ? value : current.subject;
      const aux = type === 'aux' ? value : current.aux;

      if (subj && aux) {
        const cleanSubj = clean(subj).toLowerCase();
        const cleanAux = clean(aux).toLowerCase();
        const isI = cleanSubj.startsWith("i");
        const isThirdSing = ["he", "she", "it", "my mother", "my father", "the cat", "the teacher", "the dog", "the bird", "the lion", "the monkey", "the elephant"].includes(cleanSubj);
        const isPlural = ["you", "we", "they", "students", "the boys", "the girls", "your friend"].includes(cleanSubj);

        if (cleanAux === "am" && !isI) return false;
        if (cleanAux === "is" && !isThirdSing) return false;
        if (cleanAux === "are" && !isPlural) return false;
        if (cleanAux === "do" && isThirdSing) return false;
        if (cleanAux === "does" && !isThirdSing) return false;
        if (cleanAux === "don't" && isThirdSing) return false;
        if (cleanAux === "doesn't" && (isI || isPlural)) return false;
      }
      const verbRaw = (type === 'verb' || type === 'ingVerb') ? value : (current.verb || current.ingVerb);
      const objRaw = type === 'object' ? value : current.object;
      if (verbRaw && objRaw) return checkSemanticOnly(verbRaw, objRaw);
      return true;
    };

    const applyGrammarRules = () => {
      if (!state.sentence.subject) return;
      if (state.mode === 'simple' && state.sentence.verb) {
        const cleanSubj = clean(state.sentence.subject).toLowerCase();
        const isThirdSing = ["he", "she", "it", "my mother", "my father", "the cat", "the teacher", "the dog", "the bird", "the lion", "the monkey", "the elephant"].includes(cleanSubj);
        const parts = state.sentence.verb.split(' ');
        const base = parts[0].replace(/s$/, '').replace(/es$/, '');
        const emoji = parts.slice(1).join(' ');
        let target = state.sentence.verb;
        if (isThirdSing) {
          const s = (base.endsWith('sh') || base.endsWith('ch') || base.endsWith('ss')) ? 'es' : 's';
          target = `${base}${s} ${emoji}`.trim();
        } else { target = `${base} ${emoji}`.trim(); }
        
        if (state.sentence.verb !== target) {
          state.sentence.verb = target;
          const slot = document.querySelector(`.puzzle-slot[data-type="verb"]`);
          if (slot) {
            slot.classList.add('animate-highlight');
            setTimeout(() => slot.classList.remove('animate-highlight'), 1200);
          }
        }
      }
    };

    const processPlacement = (targetType, sourceData) => {
      const isVerbMatch = (targetType === 'verb' && (sourceData.type === 'verb' || sourceData.type === 'ingVerb'));
      const isAuxMatch = (targetType === 'aux' && (sourceData.type === 'aux' || sourceData.type === 'modal'));
      
      if (sourceData.type === targetType || isVerbMatch || isAuxMatch) {
        const actualType = isVerbMatch ? sourceData.type : (isAuxMatch ? sourceData.type : targetType);
        
        if (!validateHarmony(actualType, sourceData.value, state.sentence)) {
          const slotEl = document.querySelector(`.puzzle-slot[data-type="${targetType}"]`);
          if (slotEl) {
            slotEl.classList.add('animate-bounce-error');
            const path = slotEl.querySelector('path');
            if(path) { path.setAttribute('stroke', '#b91c1c'); path.setAttribute('fill', '#ef4444'); }
            setTimeout(() => {
              slotEl.classList.remove('animate-bounce-error');
              updateUI();
            }, 800);
          }
          return;
        }

        state.sentence[actualType] = sourceData.value;
        applyGrammarRules();
        
        let isFinished = false;
        const sen = state.sentence;
        const m = state.mode;
        if (m === 'question') isFinished = (sen.aux && sen.subject && (sen.verb || sen.ingVerb) && sen.object);
        else if (m === 'modal' || m === 'negative') isFinished = (sen.subject && (sen.modal || sen.aux) && sen.verb && sen.object);
        else if (m === 'status') isFinished = (sen.subject && sen.aux && sen.adjective);
        else if (m === 'continuous') isFinished = (sen.subject && sen.aux && sen.ingVerb && sen.object);
        else isFinished = (sen.subject && sen.verb && sen.object);
        
        if (isFinished && !state.isComplete) {
          state.isComplete = true;
          state.leftDrawerOpen = false;
          state.rightDrawerOpen = false;
          state.selectedPiece = null;
          state.score += 1;
          
          if (state.score % 10 === 0 && state.score > 0) triggerConfetti(true);
          else triggerConfetti(false);

          updateUI(); 
          generateLocalTranslation();
          playLocalTTS(getFullText());
        } else {
          state.selectedPiece = null;
          state.leftDrawerOpen = false;
          state.rightDrawerOpen = false;
          updateUI();
        }
      } else {
        state.selectedPiece = null; 
        updateUI();
      }
    };

    // --- YEREL √áEVƒ∞Rƒ∞ VE SES (API OLMADAN) ---

    const generateLocalTranslation = () => {
      const s = state.sentence;
      const cleanSubjEn = clean(s.subject).toLowerCase();
      let trSubj = TR_DICT[cleanSubjEn] || clean(s.subject);
      
      let trObj = TR_DICT[clean(s.object).toLowerCase()] || clean(s.object);
      let trAdj = TR_DICT[clean(s.adjective).toLowerCase()] || clean(s.adjective);
      let baseVerbEn = getPureBaseVerb(s.verb || s.ingVerb);

      let finalSentence = "";

      if (state.mode === 'status') {
         finalSentence = `${trSubj} ${trAdj}.`;
      } else {
         const isI = cleanSubjEn === 'i';
         const isWe = cleanSubjEn === 'we';
         const isYou = cleanSubjEn === 'you';
         const isThey = ['they', 'students', 'the boys', 'the girls'].includes(cleanSubjEn);

         const verbs = {
            "eat": { aorist: "yer", prog: "yiyor", abil: "yiyebilir", neg: "yeme" },
            "drink": { aorist: "i√ßer", prog: "i√ßiyor", abil: "i√ßebilir", neg: "i√ßme" },
            "watch": { aorist: "izler", prog: "izliyor", abil: "izleyebilir", neg: "izleme" },
            "read": { aorist: "okur", prog: "okuyor", abil: "okuyabilir", neg: "okuma" },
            "play": { aorist: "oynar", prog: "oynuyor", abil: "oynayabilir", neg: "oynama" },
            "cook": { aorist: "pi≈üirir", prog: "pi≈üiriyor", abil: "pi≈üirebilir", neg: "pi≈üirme" },
            "clean": { aorist: "temizler", prog: "temizliyor", abil: "temizleyebilir", neg: "temizleme" },
            "wash": { aorist: "yƒ±kar", prog: "yƒ±kƒ±yor", abil: "yƒ±kayabilir", neg: "yƒ±kama" },
            "like": { aorist: "sever", prog: "seviyor", abil: "sevebilir", neg: "sevme" },
            "want": { aorist: "ister", prog: "istiyor", abil: "isteyebilir", neg: "isteme" },
            "have": { aorist: "sahip olur", prog: "sahip oluyor", abil: "sahip olabilir", neg: "sahip olma" },
            "buy": { aorist: "alƒ±r", prog: "alƒ±yor", abil: "alabilir", neg: "alma" },
            "see": { aorist: "g√∂r√ºr", prog: "g√∂r√ºyor", abil: "g√∂rebilir", neg: "g√∂rme" },
            "go": { aorist: "gider", prog: "gidiyor", abil: "gidebilir", neg: "gitme" },
            "write": { aorist: "yazar", prog: "yazƒ±yor", abil: "yazabilir", neg: "yazma" },
            "use": { aorist: "kullanƒ±r", prog: "kullanƒ±yor", abil: "kullanabilir", neg: "kullanma" },
            "open": { aorist: "a√ßar", prog: "a√ßƒ±yor", abil: "a√ßabilir", neg: "a√ßma" },
            "need": { aorist: "ihtiya√ß duyar", prog: "ihtiya√ß duyuyor", abil: "ihtiya√ß duyabilir", neg: "ihtiya√ß duyma" },
            "sleep": { aorist: "uyur", prog: "uyuyor", abil: "uyuyabilir", neg: "uyuma" },
            "run": { aorist: "ko≈üar", prog: "ko≈üuyor", abil: "ko≈üabilir", neg: "ko≈üma" },
            "jump": { aorist: "zƒ±plar", prog: "zƒ±plƒ±yor", abil: "zƒ±playabilir", neg: "zƒ±plama" },
            "win": { aorist: "kazanƒ±r", prog: "kazanƒ±yor", abil: "kazanabilir", neg: "kazanma" },
            "find": { aorist: "bulur", prog: "buluyor", abil: "bulabilir", neg: "bulma" },
            "start": { aorist: "ba≈ülar", prog: "ba≈ülƒ±yor", abil: "ba≈ülayabilir", neg: "ba≈ülama" },
            "learn": { aorist: "√∂ƒürenir", prog: "√∂ƒüreniyor", abil: "√∂ƒürenebilir", neg: "√∂ƒürenme" }
         };

         const v = verbs[baseVerbEn] || { aorist: TR_DICT[baseVerbEn] || baseVerbEn, prog: baseVerbEn, abil: baseVerbEn, neg: baseVerbEn };

         const getLastVowel = (word) => {
             const vowels = word.match(/[aƒ±eiou√∂√º]/gi);
             return vowels ? vowels[vowels.length - 1] : 'e';
         };

         const getPersonSuffix = (word, tense) => {
             const lw = getLastVowel(word);
             if (tense === 'prog') {
                 if (isI) return 'um'; if (isWe) return 'uz'; if (isYou) return 'sun'; if (isThey) return 'lar'; return '';
             }
             if (tense === 'aorist' || tense === 'abil') {
                 if (isI) return ['e','i'].includes(lw)?'im':['a','ƒ±'].includes(lw)?'ƒ±m':['o','u'].includes(lw)?'um':'√ºm';
                 if (isWe) return ['e','i'].includes(lw)?'iz':['a','ƒ±'].includes(lw)?'ƒ±z':['o','u'].includes(lw)?'uz':'√ºz';
                 if (isYou) return ['e','i'].includes(lw)?'sin':['a','ƒ±'].includes(lw)?'sƒ±n':['o','u'].includes(lw)?'sun':'s√ºn';
                 if (isThey) return ['e','i','√∂','√º'].includes(lw)?'ler':'lar';
                 return '';
             }
             return '';
         };

         let trVerbRoot = "";

         if (state.mode === 'continuous') {
             trVerbRoot = v.prog + getPersonSuffix(v.prog, 'prog');
             finalSentence = `${trSubj} ≈üu an ${trObj} ${trVerbRoot}.`;
         } else if (state.mode === 'modal') {
             trVerbRoot = v.abil + getPersonSuffix(v.abil, 'abil');
             finalSentence = `${trSubj} ${trObj} ${trVerbRoot}.`;
         } else if (state.mode === 'negative') {
             let negVerb = "";
             if (isI) negVerb = v.neg + "m";
             else if (isWe) negVerb = v.neg + (getLastVowel(v.neg) === 'e' ? 'yiz' : 'yƒ±z');
             else if (isYou) negVerb = v.neg + (getLastVowel(v.neg) === 'e' ? 'zsin' : 'zsƒ±n');
             else if (isThey) negVerb = v.neg + (getLastVowel(v.neg) === 'e' ? 'zler' : 'zlar');
             else negVerb = v.neg + "z";
             finalSentence = `${trSubj} ${trObj} ${negVerb}.`;
         } else if (state.mode === 'question') {
             trVerbRoot = v.aorist;
             if (isThey) {
                let lwBase = getLastVowel(trVerbRoot);
                let pluralSuffix = ['e','i','√∂','√º'].includes(lwBase) ? 'ler' : 'lar';
                trVerbRoot += pluralSuffix;
             }
             
             let lw = getLastVowel(trVerbRoot);
             let qPart = ['e','i'].includes(lw)?'mi':['a','ƒ±'].includes(lw)?'mƒ±':['o','u'].includes(lw)?'mu':'m√º';
             let qSuffix = '';
             if (isI) qSuffix = qPart === 'mi'?'yim':qPart === 'mƒ±'?'yƒ±m':qPart === 'mu'?'yum':'y√ºm';
             else if (isWe) qSuffix = qPart === 'mi'?'yiz':qPart === 'mƒ±'?'yƒ±z':qPart === 'mu'?'yuz':'y√ºz';
             else if (isYou) qSuffix = qPart === 'mi'?'sin':qPart === 'mƒ±'?'sƒ±n':qPart === 'mu'?'sun':'s√ºn';
             
             finalSentence = `${trSubj} ${trObj} ${trVerbRoot} ${qPart}${qSuffix}?`;
         } else {
             trVerbRoot = v.aorist + getPersonSuffix(v.aorist, 'aorist');
             finalSentence = `${trSubj} ${trObj} ${trVerbRoot}.`;
         }
      }

      finalSentence = finalSentence.replace(/\s+/g, ' ').replace(' .', '.').replace(' ?', '?').trim();
      finalSentence = finalSentence.charAt(0).toUpperCase() + finalSentence.slice(1);
      
      state.translation = finalSentence;
      updateUI();
    };

    const playLocalTTS = (text) => {
      if (!('speechSynthesis' in window)) return;
      
      state.isSpeaking = true; updateUI();
      
      window.speechSynthesis.cancel();

      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'en-US';
      utterance.rate = 0.85; 
      utterance.pitch = 1.2; 
      
      utterance.onend = () => { state.isSpeaking = false; updateUI(); };
      utterance.onerror = () => { state.isSpeaking = false; updateUI(); };
      
      window.speechSynthesis.speak(utterance);
    };

    const toggleRecording = () => {
      const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
      
      if (!SpeechRecognitionAPI) {
        state.pronunciationFeedback = `Mikrofonu kullanamƒ±yorum ${state.userName}! Tarayƒ±cƒ±n bunu desteklemiyor (Chrome √∂nerilir) üéôÔ∏è`;
        updateUI();
        return;
      }

      if (state.micSuccess || state.micAttempts >= 3) return;

      if (state.isRecording) {
        if (localSpeechRecognition) localSpeechRecognition.stop();
        state.isRecording = false; 
        updateUI();
      } else {
        state.pronunciationFeedback = ''; 
        state.isRecording = true; 
        updateUI();

        localSpeechRecognition = new SpeechRecognitionAPI();
        localSpeechRecognition.lang = 'en-US';
        localSpeechRecognition.interimResults = false;
        localSpeechRecognition.maxAlternatives = 1;

        localSpeechRecognition.onresult = (event) => {
           const transcriptRaw = event.results[0][0].transcript;
           const transcript = transcriptRaw.toLowerCase().replace(/[.,?!]/g, '').trim();
           const target = getFullText().toLowerCase().replace(/[.,?!]/g, '').trim();
           
           if (target.includes(transcript) || transcript.includes(target) || transcript === target) {
              state.micSuccess = true;
              state.score += 1;
              if (state.score % 10 === 0 && state.score > 0) triggerConfetti(true);
              state.pronunciationFeedback = `<span class="text-slate-500 font-bold text-[10px] block mb-1">Duyduƒüum: "${transcriptRaw}"</span><span class="text-green-600">Harika okudun ${state.userName}! üåü +1 ‚≠ê Kazandƒ±n!</span>`;
           } else {
              state.micAttempts += 1;
              if (state.micAttempts < 3) {
                 state.pronunciationFeedback = `<span class="text-slate-500 font-bold text-[10px] block mb-1">Duyduƒüum: "${transcriptRaw}"</span><span class="text-indigo-600">Biraz hatalƒ± oldu sanki. ${3 - state.micAttempts} hakkƒ±n kaldƒ±, tekrar dene! üí™</span>`;
              } else {
                 state.pronunciationFeedback = `<span class="text-slate-500 font-bold text-[10px] block mb-1">Duyduƒüum: "${transcriptRaw}"</span><span class="text-slate-600">Saƒülƒ±k olsun ${state.userName}! Sonraki c√ºmleye ge√ßelim! üòä</span>`;
              }
           }
           state.isRecording = false;
           updateUI();
        };

        localSpeechRecognition.onerror = (event) => {
           state.isRecording = false;
           state.pronunciationFeedback = `<span class="text-red-500 font-bold">Seni duyamadƒ±m ${state.userName}! (Hata: ${event.error}) üé§</span>`;
           updateUI();
        };

        localSpeechRecognition.onend = () => {
           state.isRecording = false;
           updateUI();
        };

        localSpeechRecognition.start();
      }
    };

    // --- HTML RENDER FONKSƒ∞YONLARI ---

    function triggerConfetti(isLevelUp) {
      const colors = ['#f59e0b', '#ef4444', '#3b82f6', '#10b981', '#a855f7', '#ec4899', '#f97316', '#fbbf24'];
      const count = isLevelUp ? 200 : 60; 
      const container = document.createElement('div');
      container.className = 'fixed inset-0 pointer-events-none z-[100] overflow-hidden';
      
      for(let i=0; i<count; i++) {
        const p = document.createElement('div');
        const size = Math.random() * (isLevelUp ? 12 : 8) + 6 + 'px';
        p.className = 'confetti-particle';
        p.style.left = Math.random() * 100 + 'vw';
        p.style.width = size; p.style.height = size;
        p.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        p.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
        p.style.animationDuration = Math.random() * 2.5 + 2 + 's';
        p.style.animationDelay = Math.random() * 0.5 + 's';
        container.appendChild(p);
      }
      document.body.appendChild(container);
      setTimeout(() => { if (document.body.contains(container)) document.body.removeChild(container); }, 5000);
    }

    const renderPuzzlePiece = ({ type, color, content, isSelected, isSelectedPiece, isSlot, shape, isInvalid, isComplete }) => {
      const isPlacedInSlot = isSlot && content;
      const currentWidth = isPlacedInSlot ? 220 : 170;
      const currentHeight = isPlacedInSlot ? 68 : 52; 

      const paths = {
        SUBJ_START: `M0,10 Q0,0 10,0 L170,0 L170,20 L195,40 L170,60 L170,80 L10,80 Q0,80 0,70 Z`,
        SUBJ_MID: `M30,0 L170,0 L170,20 L195,40 L170,60 L170,80 L30,80 L30,60 L55,40 L30,20 L30,0 Z`,
        VERB_SIMPLE: `M30,0 L170,0 L170,25 L190,25 L190,55 L170,55 L170,80 L30,80 L30,60 L55,40 L30,20 L30,0 Z`,
        BE_MODAL: `M30,0 L170,0 L170,20 L195,40 L170,60 L170,80 L30,80 L30,60 L55,40 L30,20 L30,0 Z`,
        AUX_START: `M0,10 Q0,0 10,0 L170,0 L170,20 L195,40 L170,60 L170,80 L10,80 Q0,80 0,70 Z`,
        VERB_ING: `M30,0 L170,0 L170,25 L190,25 L190,55 L170,55 L170,80 L30,80 L30,55 L50,55 L50,25 L30,25 L30,0 Z`,
        ADJECTIVE: `M30,0 L190,0 Q200,0 200,10 L200,70 Q200,80 190,80 L30,80 L30,65 L45,65 L45,50 L30,50 L30,30 L45,30 L45,15 L30,15 L30,0 Z`,
        VERB_BASE: `M30,0 L170,0 L170,25 L190,25 L190,55 L170,55 L170,80 L30,80 L30,65 L45,65 L45,50 L30,50 L30,30 L45,30 L45,15 L30,15 L30,0 Z`,
        OBJ_END: `M30,0 L190,0 Q200,0 200,10 L200,70 Q200,80 190,80 L30,80 L30,55 L50,55 L50,25 L30,25 L30,0 Z`
      };

      let formattedContent = '';
      if (content) {
        const text = content.replace('_adj', '').replace('_v', '');
        const parts = text.split(/(\p{Emoji})/u);
        formattedContent = parts.map(part => {
          if (/\p{Emoji}/u.test(part)) {
            const classStr = isPlacedInSlot 
               ? `inline-block text-[1.6rem] mx-1.5 transform scale-110` 
               : `inline-block text-xl mx-1 transform scale-125`;
            return `<span class="${classStr}">${part}</span>`;
          }
          return `<span>${part}</span>`;
        }).join('');
      }

      const pieceColor = isInvalid ? '#ef4444' : (content ? color : (isSelectedPiece ? '#e2e8f0' : '#f8fafc'));
      const strokeColor = isSelectedPiece ? '#eab308' : (isInvalid ? '#b91c1c' : (content ? 'rgba(0,0,0,0.2)' : '#cbd5e1'));

      const dragAttr = (!!content && !isSlot) ? 'draggable="true"' : '';
      const dataAttrs = `data-type="${type}" ${content ? `data-value="${escapeHTML(content)}"` : ''}`;
      const actionAttr = isSlot ? `data-action="slot-click"` : `data-action="piece-click"`;

      let classes = `puzzle-piece relative transition-all duration-500 ease-out transform flex flex-col items-center justify-center`;
      if (isSlot) classes += ` puzzle-slot cursor-pointer`;
      else classes += ` cursor-grab active:cursor-grabbing`;

      if (isSelected && !isSlot) classes += ` opacity-40 grayscale-[0.5]`;
      else if (!isSlot) classes += ` hover:scale-102`;

      if (isSelectedPiece) classes += ` scale-105 drop-shadow-2xl z-20`;

      return `
        <div class="${classes}" style="width: 100%; max-width: ${currentWidth}px; height: ${currentHeight}px;" ${dragAttr} ${dataAttrs} ${actionAttr}>
          <svg viewBox="0 0 200 80" preserveAspectRatio="none" class="w-full h-full drop-shadow-md transition-all absolute inset-0 ${isSelectedPiece ? 'brightness-105' : ''}">
            <path d="${paths[shape] || paths.SUBJ_START}" fill="${pieceColor}" stroke="${strokeColor}" stroke-width="${isInvalid || isSelectedPiece ? "4" : "2"}" stroke-dasharray="${!content ? "6,4" : "0"}"></path>
          </svg>
          <div class="absolute inset-0 flex flex-col items-center justify-center p-2 pointer-events-none overflow-hidden text-center z-10">
            <span class="font-black tracking-tight transition-all flex items-center justify-center flex-wrap ${content ? 'text-white' : 'text-slate-400 uppercase tracking-widest opacity-60'} ${isPlacedInSlot ? 'text-xs md:text-sm lg:text-base px-4' : 'text-[9px] md:text-[10px] px-2'}">
              ${content ? formattedContent : type}
            </span>
          </div>
        </div>
      `;
    };

    const renderLogin = () => `
      <div class="min-h-screen bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center p-4">
        <div class="bg-white p-8 md:p-10 rounded-[3rem] shadow-2xl max-w-md w-full text-center transform transition-all scale-100">
          <div class="relative inline-block mb-6">
             <div class="w-24 h-24 rounded-full flex items-center justify-center transition-all bg-indigo-100 text-indigo-500">
                <i data-lucide="user-circle" class="w-16 h-16"></i>
             </div>
             <div class="absolute -bottom-2 -right-2 bg-white rounded-full p-1 shadow-md text-amber-400 fill-amber-400"><i data-lucide="star" class="w-6 h-6"></i></div>
          </div>
          <h1 class="text-2xl md:text-3xl font-black text-slate-800 mb-2 italic">Ho≈ü Geldin!</h1>
          <p class="text-slate-500 font-bold mb-6 text-base md:text-lg">ƒ∞ngilizce oynamaya hazƒ±r mƒ±sƒ±n?</p>
          <input type="text" id="nameInput" placeholder="Adƒ±nƒ± buraya yaz..." value="${escapeHTML(state.nameInput)}" class="w-full bg-slate-100 border-2 border-slate-200 px-6 py-4 rounded-3xl font-black text-lg focus:outline-none focus:border-indigo-400 transition-all text-center mb-6" />
          <button data-action="start-game" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-black text-xl py-4 rounded-3xl shadow-lg flex items-center justify-center gap-3 transition-transform active:scale-95">
            <i data-lucide="play-circle" class="w-7 h-7"></i> BA≈ûLA
          </button>
        </div>
      </div>
    `;

    const renderHeader = () => `
      <header class="bg-white border-b border-slate-200 p-2 md:px-4 md:py-2 flex flex-col md:flex-row items-center justify-between shadow-sm z-20 shrink-0 gap-2 md:gap-0">
        <div class="flex items-center gap-2 md:gap-3 w-full md:w-auto justify-between md:justify-start">
          <div class="flex items-center gap-2">
            <div class="px-2 py-1.5 md:px-3 rounded-xl border flex items-center gap-2 bg-indigo-50 border-indigo-100">
              <i data-lucide="user-circle" class="text-indigo-500 w-4 h-4 md:w-5 md:h-5"></i>
              <span class="font-black text-slate-700 text-xs md:text-sm whitespace-nowrap">${escapeHTML(state.userName)}</span>
            </div>
            <div class="flex items-center gap-1 px-2 py-1.5 md:px-3 rounded-xl border shadow-sm transition-all duration-300 ${state.score >= 10 ? 'bg-indigo-50 border-indigo-300 scale-105' : 'bg-amber-50 border-amber-200'}" title="Kazanƒ±lan Yƒ±ldƒ±zlar">
              <i data-lucide="star" class="${state.score >= 10 ? 'text-indigo-500 fill-indigo-400' : 'text-amber-500 fill-amber-400'} w-4 h-4"></i>
              <span class="font-black text-xs md:text-sm ${state.score >= 10 ? 'text-indigo-700' : 'text-amber-700'}">${state.score}</span>
            </div>
          </div>
          
          <div class="flex gap-1 bg-slate-50 p-1 rounded-xl border border-slate-200 overflow-x-auto hide-scrollbar">
            ${Object.values(CATEGORIES).map(cat => {
              const isLocked = cat.requiredStars > 0 && state.score < cat.requiredStars;
              const btnClass = isLocked ? 'opacity-40 cursor-not-allowed bg-slate-200 text-slate-500' : (state.activeCategory === cat.id ? 'text-white shadow-sm' : 'text-slate-500 hover:bg-white');
              const btnStyle = state.activeCategory === cat.id ? `background-color: ${cat.color}` : 'background-color: transparent';
              return `
                <button data-action="${isLocked ? '' : 'set-category'}" data-payload="${cat.id}" style="${btnStyle}" class="flex items-center gap-1 px-2 md:px-3 py-1 rounded-lg font-bold text-[10px] md:text-xs transition-all whitespace-nowrap ${btnClass}">
                  <i data-lucide="${isLocked ? 'lock' : cat.icon}" class="w-3.5 h-3.5"></i> ${cat.label}
                </button>`;
            }).join('')}
          </div>
        </div>
        <div class="flex gap-1 bg-slate-50 p-1 rounded-xl border border-slate-200 w-full md:w-auto overflow-x-auto hide-scrollbar justify-center">
          ${Object.keys(MODE_LABELS).map(m => `
            <button data-action="set-mode" data-payload="${m}" class="px-2 py-1 md:px-3 rounded-lg font-black text-[9px] md:text-[10px] uppercase transition-all whitespace-nowrap ${state.mode === m ? 'bg-slate-800 text-white shadow-sm' : 'text-slate-400 hover:bg-white'}">
              ${MODE_LABELS[m]}
            </button>
          `).join('')}
        </div>
      </header>
    `;

    const renderAssemblyArea = () => {
      let html = '';
      const s = state.sentence;
      const m = state.mode;
      const sp = state.selectedPiece;
      
      const renderPz = (type, color, content, shape) => renderPuzzlePiece({
        type, color, content, shape, isSlot: true, isComplete: state.isComplete,
        isSelectedPiece: sp?.type === type && sp?.value === content
      });

      if (m === 'question') {
        html += renderPz('aux', '#6366f1', s.aux, 'AUX_START');
        html += renderPz('subject', '#3b82f6', s.subject, 'SUBJ_MID');
        html += renderPz('verb', '#ef4444', s.verb || s.ingVerb, 'VERB_SIMPLE');
        html += renderPz('object', '#22c55e', s.object, 'OBJ_END');
        html += `<span class="text-6xl font-black text-indigo-600 ml-6 md:ml-10">?</span>`;
      } else if (m === 'negative') {
        html += renderPz('subject', '#3b82f6', s.subject, 'SUBJ_START');
        html += renderPz('aux', '#ec4899', s.aux, 'BE_MODAL');
        html += renderPz('verb', '#f97316', s.verb, 'VERB_BASE');
        html += renderPz('object', '#22c55e', s.object, 'OBJ_END');
      } else if (m === 'modal') {
        html += renderPz('subject', '#3b82f6', s.subject, 'SUBJ_START');
        html += renderPz('modal', '#f59e0b', s.modal, 'BE_MODAL');
        html += renderPz('verb', '#ef4444', s.verb, 'VERB_BASE');
        html += renderPz('object', '#22c55e', s.object, 'OBJ_END');
      } else {
        html += renderPz('subject', '#3b82f6', s.subject, 'SUBJ_START');
        if (m === 'status' || m === 'continuous') html += renderPz('aux', '#0d9488', s.aux, 'BE_MODAL');
        if (m === 'status') html += renderPz('adjective', '#8b5cf6', s.adjective, 'ADJECTIVE');
        else {
          html += renderPz('verb', '#ef4444', s.verb || s.ingVerb, m === 'continuous' ? 'VERB_ING' : 'VERB_SIMPLE');
          html += renderPz('object', '#22c55e', s.object, 'OBJ_END');
        }
      }
      return html;
    };

    const getAuxItems = () => {
      const cData = CATEGORIES[state.activeCategory];
      if (state.mode === 'question') return cData.auxiliaries || [];
      if (state.mode === 'negative') return ["don't", "doesn't"];
      if (state.mode === 'modal') return cData.modals || [];
      if (state.mode === 'status' || state.mode === 'continuous') return cData.statusAux || [];
      return [];
    };

    const getVerbItems = () => {
      const cData = CATEGORIES[state.activeCategory];
      if (state.mode === 'status') return [];
      return cData.verbs || [];
    };

    const renderFooterPanels = () => {
      const sp = state.selectedPiece;
      const auxItems = getAuxItems();
      const verbItems = getVerbItems();

      const renderAuxCol = (items, wClass) => `
        <div class="${wClass} flex flex-col border-r border-slate-100">
          <h3 class="bg-indigo-600 text-white text-[9px] md:text-[10px] font-black uppercase tracking-widest text-center py-1 md:py-2 flex items-center justify-center gap-1">
             <i data-lucide="zap" class="w-2.5 h-2.5"></i> YARDIMCILAR
          </h3>
          <div class="flex-1 overflow-y-auto p-2 custom-scrollbar">
             <div class="grid grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-2 justify-items-center w-full">
               ${items.map(a => renderPuzzlePiece({ 
                  type: state.mode === 'modal' ? 'modal' : 'aux', 
                  color: state.mode === 'negative' ? '#ec4899' : (state.mode === 'modal' ? '#f59e0b' : (state.mode === 'question' ? '#6366f1' : '#0d9488')), 
                  content: a, 
                  isSelected: state.mode === 'modal' ? state.sentence.modal === a : state.sentence.aux === a, 
                  isSelectedPiece: sp?.type === (state.mode === 'modal' ? 'modal' : 'aux') && sp?.value === a, 
                  shape: state.mode === 'question' ? 'AUX_START' : 'BE_MODAL' 
                })).join('')}
             </div>
          </div>
        </div>
      `;

      const renderVerbCol = (items, wClass) => `
        <div class="${wClass} flex flex-col">
          <h3 class="bg-red-600 text-white text-[9px] md:text-[10px] font-black uppercase tracking-widest text-center py-1 md:py-2 flex items-center justify-center gap-1">
             <i data-lucide="puzzle" class="w-2.5 h-2.5"></i> EYLEMLER
          </h3>
          <div class="flex-1 overflow-y-auto p-2 custom-scrollbar">
             <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-2 justify-items-center w-full">
               ${items.map(v => {
                 if (state.mode === 'continuous') {
                   const ingVal = v.split(' ')[0] + 'ing ' + (v.split(' ')[1] || '');
                   return renderPuzzlePiece({ type: 'ingVerb', color: '#f97316', content: ingVal, isSelected: state.sentence.ingVerb === ingVal, isSelectedPiece: sp?.type === 'ingVerb' && sp?.value === ingVal, shape: 'VERB_ING' });
                 }
                 return renderPuzzlePiece({ type: 'verb', color: state.mode === 'negative' ? '#f97316' : '#ef4444', content: v, isSelected: state.sentence.verb === v, isSelectedPiece: sp?.type === 'verb' && sp?.value === v, shape: (state.mode === 'modal' || state.mode === 'negative') ? 'VERB_BASE' : 'VERB_SIMPLE' });
               }).join('')}
             </div>
          </div>
        </div>
      `;

      let html = '';
      if (auxItems.length > 0 && verbItems.length > 0) {
        html += renderAuxCol(auxItems, 'w-1/3');
        html += renderVerbCol(verbItems, 'w-2/3');
      } else if (auxItems.length > 0) {
        html += renderAuxCol(auxItems, 'w-full border-r-0');
      } else if (verbItems.length > 0) {
        html += renderVerbCol(verbItems, 'w-full');
      }
      return html;
    };

    const renderApp = () => {
      const cData = CATEGORIES[state.activeCategory];
      const sp = state.selectedPiece;

      return `
        ${(state.leftDrawerOpen || state.rightDrawerOpen) ? `<div class="fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-30 md:hidden" data-action="close-drawers"></div>` : ''}

        <div class="absolute left-0 top-[40%] -translate-y-1/2 z-20 md:hidden">
          <button data-action="toggle-left-drawer" class="bg-blue-600/90 text-white p-2 py-6 rounded-r-2xl shadow-lg flex flex-col items-center gap-2 backdrop-blur-sm active:scale-95 transition-transform">
             <i data-lucide="arrow-right-circle" class="w-5 h-5"></i>
             <span class="font-black text-xs" style="writing-mode: vertical-rl;">Kƒ∞M?</span>
          </button>
        </div>
        <div class="absolute right-0 top-[40%] -translate-y-1/2 z-20 md:hidden">
          <button data-action="toggle-right-drawer" class="bg-green-600/90 text-white p-2 py-6 rounded-l-2xl shadow-lg flex flex-col items-center gap-2 backdrop-blur-sm active:scale-95 transition-transform">
             <i data-lucide="arrow-left-circle" class="w-5 h-5"></i>
             <span class="font-black text-xs" style="writing-mode: vertical-rl;">NEYƒ∞?</span>
          </button>
        </div>

        ${renderHeader()}

        <div class="flex-1 flex overflow-hidden">
          
          <!-- SOL VE ORTA KISIM ƒ∞√áƒ∞N KAPSAYICI -->
          <div class="flex-1 flex flex-col min-w-0 overflow-hidden">
            
            <div class="flex-1 flex overflow-hidden">
              <!-- SOL MEN√ú (Kƒ∞M?) √áƒ∞FT SIRA -->
              <aside class="fixed md:relative inset-y-0 left-0 w-[370px] bg-white border-r border-slate-200 flex flex-col shadow-2xl md:shadow-inner z-40 transform transition-transform duration-300 md:translate-x-0 shrink-0 ${state.leftDrawerOpen ? 'translate-x-0' : '-translate-x-full'}">
                <div class="bg-blue-600 text-white text-[10px] font-black uppercase tracking-widest text-center py-3 italic shadow-sm flex items-center justify-center relative">
                  Kƒ∞M? (SUBJECT)
                  <button class="md:hidden absolute right-3 text-blue-200 hover:text-white" data-action="close-drawers"><i data-lucide="x-circle" class="w-4 h-4"></i></button>
                </div>
                <div class="flex-1 overflow-y-auto p-2 custom-scrollbar">
                  <!-- √áift Sƒ±ra Grid -->
                  <div class="grid grid-cols-2 gap-2 justify-items-center w-full">
                    ${cData.subjects.map(s => renderPuzzlePiece({ type: 'subject', color: '#3b82f6', content: s, isSelected: state.sentence.subject === s, isSelectedPiece: sp?.type === 'subject' && sp?.value === s, shape: state.mode === 'question' ? 'SUBJ_MID' : 'SUBJ_START' })).join('')}
                  </div>
                </div>
              </aside>

              <!-- ORTA ALAN -->
              <main class="flex-1 flex flex-col bg-slate-50 relative min-w-0">
                <div class="flex-1 flex flex-col items-center justify-start pt-2 md:pt-4 p-2 md:p-4 overflow-y-auto w-full">
                  
                  <div class="mb-2 md:mb-4 w-full max-w-xl transition-all duration-500 px-4">
                      <div class="p-2 md:p-3 rounded-2xl border-2 flex items-center justify-center gap-2 md:gap-3 shadow-md transition-all ${state.isComplete ? 'bg-amber-100 border-amber-300 scale-105' : 'bg-indigo-50 border-indigo-100'}">
                        ${state.score % 10 === 0 && state.score > 0 && state.isComplete ? '<i data-lucide="party-popper" class="w-5 h-5 text-indigo-500 animate-bounce"></i>' : `<i data-lucide="sparkles" class="w-4 h-4 md:w-5 md:h-5 ${state.isComplete ? 'text-amber-500 animate-pulse' : 'text-indigo-400'}"></i>`}
                        <p class="text-[10px] md:text-[12px] font-black uppercase tracking-wide text-center ${state.score % 10 === 0 && state.score > 0 && state.isComplete ? 'text-indigo-700' : (state.isComplete ? 'text-amber-800' : 'text-indigo-700')}">
                          ${getMagicRule()}
                        </p>
                      </div>
                  </div>

                  <!-- MONTAJ ALANI -->
                  <div class="bg-white rounded-[2rem] md:rounded-[3rem] w-full max-w-5xl p-2 md:p-6 shadow-xl border-2 border-slate-200 flex flex-col items-center justify-center min-h-[120px] md:min-h-[180px] relative overflow-hidden transition-all z-10">
                    <div class="flex flex-row items-center justify-center transition-all duration-300 transform scale-[0.55] sm:scale-[0.8] md:scale-90 lg:scale-100 origin-center -space-x-[45px] w-full">
                      ${renderAssemblyArea()}
                    </div>
                  </div>

                  <div class="mt-4 md:mt-4 w-full flex flex-col items-center justify-center gap-2 text-center z-10 px-2 max-w-2xl mx-auto">
                    ${state.isComplete ? `
                      <div class="p-3 md:p-4 rounded-3xl border-2 w-full animate-in slide-in-from-bottom duration-500 shadow-sm flex items-center justify-between gap-2 ${state.score % 10 === 0 && state.score > 0 ? 'bg-indigo-100 border-indigo-300' : 'bg-green-100 border-green-200'}">
                        <div class="flex-1">
                          <div class="bg-white/60 p-2 rounded-xl border border-green-200 flex items-start gap-2 shadow-inner">
                            <i data-lucide="languages" class="w-4 h-4 md:w-5 md:h-5 text-indigo-600 shrink-0 mt-0.5"></i>
                            <p class="text-xs md:text-sm font-black text-slate-800 italic leading-tight text-left">
                               ${state.translation}
                            </p>
                          </div>
                        </div>
                        <div class="p-3 rounded-full transition-all shrink-0 ${state.isSpeaking ? 'bg-amber-100 animate-pulse scale-110' : 'bg-white/50'}">
                          <i data-lucide="volume-2" class="${state.isSpeaking ? 'text-amber-600' : 'text-slate-400'} w-5 h-5"></i>
                        </div>
                      </div>
                      
                      <div class="w-full bg-blue-50 border-2 border-blue-200 rounded-3xl p-3 shadow-sm flex flex-col items-center gap-2 animate-in slide-in-from-bottom duration-700 delay-300 fill-mode-both">
                        ${(!state.micSuccess && state.micAttempts < 3) ? `
                        <div class="flex items-center justify-center gap-3 w-full">
                          <div class="flex flex-col items-end text-right">
                            <span class="font-black text-blue-700 text-sm md:text-base">Konu≈üma Sƒ±rasƒ± Sende! üé§</span>
                            <span class="text-[10px] md:text-xs text-blue-500 font-bold">
                              ${state.isRecording ? "Dinliyorum, bitirince tekrar dokun..." : "Mikrofona dokun ve c√ºmleyi oku"}
                            </span>
                          </div>
                          <button data-action="toggle-recording" class="p-3 md:p-4 rounded-full shadow-lg transition-all duration-300 flex items-center justify-center ${state.isRecording ? 'bg-red-500 text-white animate-pulse scale-110 shadow-red-200' : 'bg-blue-500 text-white hover:bg-blue-600 hover:scale-105'}">
                            <i data-lucide="mic" class="w-6 h-6"></i>
                          </button>
                        </div>
                        ` : ''}
                        ${state.pronunciationFeedback ? `
                          <div class="bg-white px-3 py-2 md:py-3 rounded-2xl border-2 ${state.micSuccess ? 'border-green-300 bg-green-50' : (state.micAttempts >= 3 ? 'border-slate-300 bg-slate-50' : 'border-indigo-200')} font-black text-xs md:text-sm text-center shadow-inner animate-in fade-in zoom-in w-full">
                            ${state.pronunciationFeedback}
                          </div>
                        ` : ''}
                      </div>
                    ` : `
                      <div class="text-slate-400 font-bold uppercase text-[9px] md:text-[10px] tracking-[0.2em] flex flex-col items-center gap-2 animate-pulse bg-slate-100 p-2 rounded-xl w-full">
                        <div class="flex items-center gap-2"><i data-lucide="mouse-pointer-click" class="w-3.5 h-3.5"></i> Dokunarak veya s√ºr√ºkleyerek oyna!</div>
                      </div>
                    `}
                  </div>
                </div>
              </main>
            </div>

            <!-- ALT MEN√ú (SADECE SOL VE ORTAYI KAPLAR) -->
            <footer class="h-44 md:h-56 bg-white border-t border-slate-200 flex flex-row shadow-inner shrink-0 relative z-20 w-full">
              ${renderFooterPanels()}
              <button data-action="reset" class="absolute bottom-2 right-2 md:bottom-4 md:right-4 bg-slate-900 text-white p-2 md:p-3 rounded-full hover:bg-orange-600 shadow-lg active:scale-95 group z-30"><i data-lucide="refresh-cw" class="w-5 h-5 md:w-6 md:h-6 group-hover:rotate-180 transition-transform duration-500"></i></button>
            </footer>

          </div>

          <!-- SAƒû MEN√ú (NEYƒ∞/NASIL?) T√úM Y√úKSEKLƒ∞ƒûƒ∞ KAPLAR VE √áƒ∞FT SIRA -->
          <aside class="fixed md:relative inset-y-0 right-0 w-[370px] bg-white border-l border-slate-200 flex flex-col shadow-2xl md:shadow-inner z-40 transform transition-transform duration-300 md:translate-x-0 shrink-0 ${state.rightDrawerOpen ? 'translate-x-0' : 'translate-x-full'} h-full">
            <div class="bg-green-600 text-white text-[10px] font-black uppercase tracking-widest text-center py-3 italic shadow-sm flex items-center justify-center relative">
              <button class="md:hidden absolute left-3 text-green-200 hover:text-white" data-action="close-drawers"><i data-lucide="x-circle" class="w-4 h-4"></i></button>
              ${state.mode === 'status' ? "NASIL? (ADJECTIVE)" : "NEYƒ∞? (OBJECT)"}
            </div>
            <div class="flex-1 overflow-y-auto p-2 custom-scrollbar">
              <!-- √áift Sƒ±ra Grid -->
              <div class="grid grid-cols-2 gap-2 justify-items-center w-full">
                ${state.mode === 'status' ? (cData.adjectives || []).map(adj => renderPuzzlePiece({ type: 'adjective', color: '#8b5cf6', content: adj, isSelected: state.sentence.adjective === adj, isSelectedPiece: sp?.type === 'adjective' && sp?.value === adj, shape: 'ADJECTIVE' })).join('') :
                  (cData.objects || []).map(o => renderPuzzlePiece({ type: 'object', color: '#22c55e', content: o, isSelected: state.sentence.object === o, isSelectedPiece: sp?.type === 'object' && sp?.value === o, shape: 'OBJ_END' })).join('')}
              </div>
            </div>
          </aside>

        </div>
      `;
    };

    // --- MAIN RENDER AND EVENT DELEGATION ---
    const updateUI = () => {
      document.getElementById('root').innerHTML = state.showLogin ? renderLogin() : renderApp();
      lucide.createIcons();
    };

    document.addEventListener('input', (e) => {
      if (e.target.id === 'nameInput') state.nameInput = e.target.value;
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && e.target.id === 'nameInput') {
        if(state.nameInput.trim()) { state.userName = state.nameInput.trim(); state.showLogin = false; updateUI(); }
      }
    });

    document.addEventListener('click', (e) => {
      const actionEl = e.target.closest('[data-action]');
      if (!actionEl) return;
      const action = actionEl.dataset.action;
      const payload = actionEl.dataset.payload;

      if (action === 'start-game') {
        if(state.nameInput.trim()) { state.userName = state.nameInput.trim(); state.showLogin = false; updateUI(); }
      } else if (action === 'set-category') {
        state.activeCategory = payload; resetGame(); updateUI();
      } else if (action === 'set-mode') {
        state.mode = payload; resetGame(); updateUI();
      } else if (action === 'reset') {
        resetGame(); updateUI();
      } else if (action === 'toggle-left-drawer') {
        state.leftDrawerOpen = true; updateUI();
      } else if (action === 'toggle-right-drawer') {
        state.rightDrawerOpen = true; updateUI();
      } else if (action === 'close-drawers') {
        state.leftDrawerOpen = false; state.rightDrawerOpen = false; updateUI();
      } else if (action === 'piece-click') {
        state.selectedPiece = { type: actionEl.dataset.type, value: actionEl.dataset.value };
        updateUI();
      } else if (action === 'slot-click') {
        if (!state.selectedPiece) return;
        processPlacement(actionEl.dataset.type, state.selectedPiece);
      } else if (action === 'toggle-recording') {
        toggleRecording();
      }
    });

    // DRAG AND DROP
    document.addEventListener('dragstart', (e) => {
      const piece = e.target.closest('.puzzle-piece');
      if (piece && piece.hasAttribute('draggable')) {
        e.dataTransfer.setData("text/plain", JSON.stringify({ type: piece.dataset.type, value: piece.dataset.value }));
      }
    });

    document.addEventListener('dragover', (e) => {
      const slot = e.target.closest('.puzzle-slot');
      if (slot) {
        e.preventDefault();
        if (currentDragSlot !== slot) {
          if (currentDragSlot) currentDragSlot.classList.remove('scale-105', 'drop-shadow-2xl', 'z-20', 'brightness-105');
          slot.classList.add('scale-105', 'drop-shadow-2xl', 'z-20', 'brightness-105');
          currentDragSlot = slot;
        }
      }
    });

    document.addEventListener('dragleave', (e) => {
      const slot = e.target.closest('.puzzle-slot');
      if (slot && currentDragSlot === slot) {
        slot.classList.remove('scale-105', 'drop-shadow-2xl', 'z-20', 'brightness-105');
        currentDragSlot = null;
      }
    });

    document.addEventListener('drop', (e) => {
      const slot = e.target.closest('.puzzle-slot');
      if (currentDragSlot) {
        currentDragSlot.classList.remove('scale-105', 'drop-shadow-2xl', 'z-20', 'brightness-105');
        currentDragSlot = null;
      }
      if (slot) {
        e.preventDefault();
        const dataStr = e.dataTransfer.getData("text/plain");
        if (!dataStr) return;
        try {
          processPlacement(slot.dataset.type, JSON.parse(dataStr));
        } catch(err) {}
      }
    });

    // Initialize
    updateUI();
  </script>
</body>
</html>